# MCTS模板与文档树MCTS搜索示例

## 项目简介

蒙特卡洛树搜索（MCTS）是一种强大的决策制定算法，它通过结合随机模拟的广度探索和树搜索的深度探索来有效解决复杂问题。这使得MCTS在许多传统算法难以处理的领域展现出卓越的性能。

具体来说，可以用于各种需要搜索的场景，比如对知识库的搜索，agent对于动作的搜索，用处非常广泛，所以我想把这个提取成模板，减少大家的重复劳动

代码仓库中包含MCTS的模板（就一个py文件），以及用MCTS实现将规范类文档解析成文档树后，在文档树上实现LLM搜索最有效段落的示例

## **MCTS的流程简介**

![undefined](https://upload.wikimedia.org/wikipedia/commons/thumb/2/21/MCTS-steps.svg/2560px-MCTS-steps.svg.png)

上图清晰地展示了MCTS的四个核心步骤：选择（Selection）、扩展（Expansion）、模拟（Simulation）和反向传播（Backpropagation）。

**1. 选择 (Selection)**

- **目标：** 从根节点开始，沿着已经探索过的最佳路径，向下选择一个“最有前途”的节点，直到到达一个未完全探索（即有未访问子节点）的节点。
- **图中体现：** 在“SELECTION”部分，粗线箭头表示从根节点（11/21）开始，选择到左侧的子节点（7/10），然后继续选择到其左侧的子节点（2/4），最终到达灰色的节点（2/3），这个节点是“当前”被选择的节点，其兄弟节点（3/3）也被选择。选择过程会根据某种策略（例如，UCB1公式）来评估节点的潜力，通常选择那些探索度不够但看起来有希望的节点。注意，在这一步中，已经访问过的节点通常会显示其胜/总次数（例如，7/10表示7次胜利，10次访问）。

**2. 扩展 (Expansion)**

- **目标：** 当选择步骤到达一个未完全探索的节点时，即该节点还有未被访问过的子节点，算法会从这个节点中选择一个或多个未访问的子节点进行扩展。
- **图中体现：** 在“EXPANSION”部分，从“SELECTION”步骤中选择的灰色的“3/3”节点向下扩展出了一个新的子节点“0/0”。这个“0/0”节点是首次被添加到搜索树中，其胜/总次数初始化为0/0。这意味着我们正在探索这个新节点代表的游戏状态。

**3. 模拟 (Simulation) / 游戏 (Playout)**

- **目标：** 从新扩展的节点（或在某些实现中，从选择到的节点开始）开始，执行一个随机的游戏模拟（或“playout”）直到游戏结束（达到终端状态）。
- **图中体现：** 在“SIMULATION”部分，从新扩展的“0/0”节点开始，用虚线箭头表示向下进行随机模拟。这个模拟会按照游戏规则随机地选择后续的行动，直到游戏结束。最终，模拟的结果（例如，胜利或失败）会被记录下来，图中显示模拟结果为“0/1”，表示在这次模拟中，该节点代表的玩家输了（或者说，没有获得胜利）。

**4. 反向传播 (Backpropagation)**

- **目标：** 将模拟的结果从终端节点（或模拟结束点）沿着之前选择的路径，向上反向传播到树的根节点。
- **图中体现：** 在“BACKPROPAGATION”部分，粗线箭头清晰地展示了模拟结果“0/1”从新扩展的节点开始，沿着选择的路径向上回溯。路径上的每个节点都会根据模拟结果更新其胜/总次数。
  - “0/1”节点更新为“0/1”。
  - 父节点“3/3”更新为“3/4”（3次胜利，4次访问）。
  - 再向上的父节点“2/3”更新为“2/4”（2次胜利，4次访问）。
  - 继续向上，其父节点“7/10”更新为“8/11”（7+1=8次胜利，10+1=11次访问）。
  - 最终，根节点“11/21”更新为“11/22”（11次胜利，21+1=22次访问）。
  - 注意：在这次反向传播中，由于模拟结果是“0”，所以只有总次数增加了1，而胜利次数没有增加（因为路径上的节点被认为是输掉了这次模拟）。如果模拟结果是“1”（胜利），那么胜/总次数都会增加。

这四个步骤循环进行，直到达到预设的迭代次数或计算时间限制。随着迭代的进行，MCTS会构建一个越来越准确的搜索树，从中可以找出最佳的行动。

## 项目文件说明

```
.
├── config.py              # 将config文件转化为可import的config变量
├── config.yaml            # 设置api_key以及图片、文档路径等
├── doc2tree               # 解析文档
│   ├── doc_parse.py       
│   ├── __init__.py
│   └── pdf_tools.py
├── xxx.png                # 示例图片
├── llms                   # 调用api（qwen）
│   ├── call_llms.py
│   └── __init__.py
├── main.py                # 示例的主调试程序
├── mcts_base              # MCTS模板以及示例实现
│   ├── __init__.py       
│   ├── mcts_backbone.py   # ！！！包含了MCTS的实现逻辑以及Node抽象类，理论上只用实现Node抽象类即可使用MCTS了
│   └── mcts_doc_tree.py   # 文档树MCTS示例
├── README.md
├── utils
│   ├── __init__.py
│   └── prompts.py
└── xxx.pdf                # 待解析的文档

```

## 配置项

```
Doc_parse:
  api_key: "sk-xxxx"                # dashscope api key
  name: "xxx.pdf"                   # 要解析的文档树
  data_path: "./"                   # 文档树的所在目录
  save_parse: True                  # 是否保存解析结果
  load_parse: False                 # 是否load解析结果而不重新解析
image_path: "./xxx.png"             # 由于示例是一个类似vqa的场景，所以会有一张参考图片
dash_scope_api_key: "sk-xxxx"       # dashscope api key
```

## 使用方法

1. 如果只是想用MCTS模板，只用复制mcts_backbone，然后继承实现Node的抽象方法就可以按照main中的流程实现了
2. 如果要debug示例，需要先在配置项中进行配置api、图片、文档，注意prompt.py中的prompt也是做了脱敏处理的，需要修改一下

## 须知

不提供任何参考数据，只做分享模板使用